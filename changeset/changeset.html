<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>changeset (changeset.changeset)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><header><nav><a href="../index.html">Up</a> â€“ package <a href="index.html">changeset</a></nav></header><p>This is the homepage for the Changeset library.</p><p>This library takes its inspiration from the <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html">Ecto.Changeset</a> module in the Elixir ecosystem.</p><h1 id="getting_started"><a href="#getting_started" class="anchor"></a>Getting started</h1><p>The Changeset library allows the programmer to validate data while enjoying the comfort of first-class and first-order labels, and the <i>pipeline</i> design approach.</p><p>Labels are <b>first-class</b>, that means you can give them as argument to functions, and <b>first-order</b>, so you can pattern match against them.</p><p>There is a <code>ppx deriving</code> plugin so there is no need to write any boilerplate code.</p><h4 id="install-using-opam"><a href="#install-using-opam" class="anchor"></a>Install using opam</h4><pre><code>$ git clone https://github.com/phink/changeset
$ cd changeset
$ opam pin add changeset .
$ opam pin add ppx_changeset .</code></pre><h4 id="setup-a-project-with-jbuilder"><a href="#setup-a-project-with-jbuilder" class="anchor"></a>Setup a project with jbuilder</h4><p>Add the following dependencies to your <code>jbuild</code> file.</p><ul><li>FIXME</li></ul><h2 id="first_example"><a href="#first_example" class="anchor"></a>Example of data validation</h2><p>Let us first illustrate the Changeset library with an example.</p><p>We start by defining a type <code>t</code> that would represent the incoming data from the outside world.</p><pre><code>type t = {
  age: int;
  phone: string;
  password: string;
} [@@deriving changeset]</code></pre><p>The <code>[@@deriving changeset]</code> ppx annotation will automatically generate:</p><ul><li>a <a href="https://caml.inria.fr/pub/docs/manual-ocaml-400/manual021.html#htoc113">GADT</a> definition whose constructors correspond to the fields of the original record type <code>t</code>. The parameter type variable of <code>label</code> aims to represent the corresponding type of the label in the record definition. In our example we have the following generated definition.</li></ul><pre><code>type 'a label =
  | Age : int label
  | Phone : string label
  | Password : string label</code></pre><ul><li>a module <code>CSet</code> of type <code>Changeset.S</code> that provides, among others, validation functions for the type <code>t</code>.</li></ul><p>We can now write a function <code>changeset_default</code> that takes a changeset <code>cset</code> and applies the desired validations. The function <code>changeset_create</code> takes a term of type <code>t</code>, creates a changeset in which all the elements in <code>t</code> are loaded as changes and then applies the validations. If some of the validations were not respected, an adequate message is registered and the changeset is considered as <b>invalid</b>.</p><p>The function <code>CSet.apply</code> returns a term of type <code>(t, CSet.t) Base.Result.t</code>. More precisely, it returns:</p><ul><li><code>Ok x</code> where <code>x</code> is a value of type <code>t</code> if the changeset <code>t</code> is valid and all the labels are present in the changes of <code>t</code>.</li></ul><ul><li><code>Error t'</code> otherwise, where <code>t'</code> corresponds to the changeset <code>t</code> if it was not valid, or <code>t</code> expanded with an error <code>(l =&gt; &quot;is missing&quot;)</code> if the changeset was valid but a <code>label</code> <code>l</code> was not found.</li></ul><pre><code>let changeset_default cset : CSet.t =
  cset
  |&gt; CSet.validate_int Age [`greater_than_or_equal_to 0]
  |&gt; CSet.validate_string_length Password [`min 12]
  |&gt; CSet.validate_format Phone (Str.regexp &quot;^\\+?[1-9][0-9]+$&quot;)

let changeset_create       t : (t, CSet.t) Base.Result.t =
  t
  |&gt; CSet.from_record
  |&gt; changeset_default
  |&gt; CSet.apply</code></pre><p>FIXME Add examples</p><h4 id="define-your-own-validation-functions"><a href="#define-your-own-validation-functions" class="anchor"></a>Define your own validation functions</h4><p>One can easily create its own validation with <code>validate_change</code>. For instance, we can create <code>validate_one_uppercase</code> that verifies if the value bound to the label passed as argument contains at least one uppercase. Otherwise a user-defined error would be registered as an association of the corresponding label and a message.</p><pre><code>let validate_one_uppercase label cset =
  let message = &quot;should contain at least one uppercase&quot; in
  let aux s =
    if not Base.(String.exists s ~f:Char.is_uppercase)
    then [message]
    else []
  in
  CSet.validate_change label aux cset</code></pre><p>The original <code>changeset_default</code> definition should be extended as follows.</p><pre><code>let changeset_default changeset =
  cset
  |&gt; CSet.validate_int Age [`greater_than_or_equal_to 0]
  |&gt; CSet.validate_string_length Password [`min 12]
  |&gt; CSet.validate_format Phone (Str.regexp &quot;^\\+?[1-9][0-9]+$&quot;)
  |&gt; validate_one_uppercase Password</code></pre><h2 id="basic-workflow"><a href="#basic-workflow" class="anchor"></a>Basic workflow</h2><p>One suggestion is to define a</p><ul><li><code>changeset_default</code> function whose goal is to verify that a changeset is well-formed.</li></ul><ul><li><code>changeset_create</code> function whose goal is to create and build the complete data before calling changeset_default.</li></ul><ul><li><code>changeset_update</code> function whose goal is to update some values in the given changeset.</li></ul><p>FIXME</p><h2 id="errors"><a href="#errors" class="anchor"></a>Errors</h2><p>FIXME</p><h2 id="incremental_building"><a href="#incremental_building" class="anchor"></a>Incremental building</h2><p>Information coming from the outside world is not always complete and, as a consequence, we usually have to deal with partial data. The <code>CSet.t</code> library feature provides a structure that corresponds to an heterogeneous map and whose keys are labels. This one allows us to incrementally build your changeset before applying the changes and returning a valid record type in case of success.</p><p>Suppose we are implementing a <i>strong password generator</i> API. The only information coming from the outside world are the phone number and the age. When creating a new changeset, we now also have to generate a password. Our <code>changeset_create</code> function would be defined as follows, assuming a function <code>generate_strong_password</code> of type <code>unit -&gt; string</code>.</p><pre><code>let changeset_create params =
  CSet.empty
  |&gt; CSet.put_changes params
  |&gt; CSet.put_change Password (generate_strong_password ())
  |&gt; changeset_default</code></pre><p>The <code>from_outside</code> function takes the incomplete <code>json</code> data and calls the <code>changeset_create</code> function in order to return a complete changeset.</p><pre><code>let from_outside json =
  let open Yojson.Basic.Util in
  let age = json |&gt; member &quot;age&quot; |&gt; to_int in
  let phone = json |&gt; member &quot;phone&quot; |&gt; to_string in
  changeset_create CSet.[Age =&gt; age; Phone =&gt; phone;]</code></pre><h2 id="limitations"><a href="#limitations" class="anchor"></a>Limitations</h2><ul><li>Parameterized types are not yet supported.</li></ul></body></html>