<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (changeset.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><header><nav><a href="../index.html">Up</a> â€“ package <a href="index.html">changeset</a></nav></header><h1 id="homepage"><a href="#homepage" class="anchor"></a>Homepage for the <code>changeset</code> library</h1><p>Data validation with first-class and first-order labels in OCaml.</p><p>Library documentation <a href="Changeset/index.html">can be found here</a>.</p><p>This library takes its inspiration from the <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html">Ecto.Changeset</a> module in the Elixir ecosystem.</p><h2 id="getting_started"><a href="#getting_started" class="anchor"></a>Getting started</h2><p><b>Changesets and data validation</b>. Changesets are tools to validate data while accumulating errors along the way. They are composed of:</p><ul><li><b>Changes</b>: an heterogeneous map whose keys are of type <code>'a label</code> and values <code>'a</code>. When deriving the changesets from a record type definition, the labels correspond to the fields of this one.</li><li><b>Errors</b>: a list of strings associated with labels.</li></ul><p>Labels are first-class, that means you can give them as argument to functions, and first-order, so you can pattern match against them. The library promotes the <i>pipeline</i> design approach.</p><p>There is a <code>ppx deriving</code> plugin so there is no need to write any boilerplate code.</p><h4 id="install-using-opam"><a href="#install-using-opam" class="anchor"></a>Install using opam</h4><pre><code>$ opam pin add changeset https://github.com/phink/changeset
$ opam pin add ppx_changeset https://github.com/phink/changeset</code></pre><p>Update the libraries and preprocess section in your jbuild file:</p><pre><code>(libraries (... changeset))
(preprocess (pps (... ppx_changeset)))</code></pre><h2 id="first_example"><a href="#first_example" class="anchor"></a>Example</h2><p>Let us illustrate the usage of the library with a first example.</p><h4 id="type-definition-and-derivation"><a href="#type-definition-and-derivation" class="anchor"></a>Type definition and derivation</h4><p>We start by defining a type <code>t</code> that would represent the incoming data.</p><pre><code>type t = {
  age: int;
  phone: string;
  password: string;
} [@@deriving changeset]</code></pre><p>The <code>[@@deriving changeset]</code> ppx annotation will generate a <a href="https://caml.inria.fr/pub/docs/manual-ocaml-400/manual021.html#htoc113">GADT</a> definition whose constructors correspond to the fields of the original record type <code>t</code>. The parameter type variable of <code>label</code> aims to represent the corresponding type of the label in the record definition. In our example we have the following generated definition.</p><pre><code>type 'a label =
  | Age : int label
  | Phone : string label
  | Password : string label</code></pre><p>It will also generate a module named <code>CSet</code> of type <a href="Changeset/module-type-S/index.html"><code>Changeset.S</code></a> that provides, among others, validation functions for the type <code>t</code>.</p><h4 id="the-workflow"><a href="#the-workflow" class="anchor"></a>The workflow</h4><p>We start by defining a function <code>validate</code> that takes a changeset <code>cset</code> (i.e. a term of type <a href="Changeset/module-type-S/index.html#type-t"><code>Changeset.S.t</code></a>), applies the desired validations, and returns the changeset potentially augmented with new errors returned by the validations.</p><pre><code>let validate cset : CSet.t =
  cset
  |&gt; CSet.validate_int Age [`greater_than_or_equal_to 0]
  |&gt; CSet.validate_string_length Password [`min 12]
  |&gt; CSet.validate_format Phone (Str.regexp &quot;^\\+?[1-9][0-9]+$&quot;)</code></pre><p>The function <code>validate</code> takes a term of type <code>t</code>, creates a changeset in which all the elements in <code>t</code> are loaded as changes using the <code>CSet.from_record</code> function and calls <code>validate</code>.</p><pre><code>let create t : (t, CSet.t) Base.Result.t =
  t
  |&gt; CSet.from_record
  |&gt; validate
  |&gt; CSet.apply</code></pre><p>If some of the validations were not respected, an error is registered and the changeset would now be considered as <b>invalid</b>.</p><p>The function <code>CSet.apply</code> returns a value of type <code>(t, CSet.t) Base.Result.t</code>. That is,</p><ul><li><code>Ok x</code> if the changeset returned by <code>validate</code> is valid.</li></ul><ul><li><code>Error cset</code> otherwise, where <code>cset</code> corresponds to the changeset returned by <code>validate</code> if it was not valid.</li></ul><h3 id="example-of-success-and-error-reporting"><a href="#example-of-success-and-error-reporting" class="anchor"></a>Example of success and error reporting</h3><pre><code>let run data =
  data
  |&gt; create
  |&gt; CSet.apply
  |&gt; function
  | Ok _t -&gt; Stdio.print_endline &quot;OK&quot;
  | Error cset -&gt; Stdio.prerr_endline (CSet.show_errors cset)</code></pre><h4 id="example-with-valid-data"><a href="#example-with-valid-data" class="anchor"></a>Example with valid data</h4><pre><code>let data : t = {
  age = 10;
  password = &quot;somethinghardtohack&quot;;
  phone = &quot;+14155552671&quot;
}</code></pre><p>Outputs the following when executing <code>run data</code>:</p><pre><code>OK</code></pre><h4 id="example-with-invalid-data"><a href="#example-with-invalid-data" class="anchor"></a>Example with invalid data</h4><pre><code>let data : t = {
  age = -1;
  password = &quot;camel&lt;3&quot;;
  phone = &quot;+14155552671&quot;
}</code></pre><p>Outputs the following when executing <code>run data</code>:</p><pre><code>{
  &quot;errors&quot;:{
    &quot;password&quot;:&quot;should be at least 12 character(s)&quot;;
    &quot;age&quot;:&quot;must be greater than or equal to 0&quot;
  }
}</code></pre><h4 id="define-your-own-validation-functions"><a href="#define-your-own-validation-functions" class="anchor"></a>Define your own validation functions</h4><p>One can easily create its own validation with <code>validate_change</code>. For instance, we can create <code>validate_one_uppercase</code> that verifies if the value bound to the label passed as argument contains at least one uppercase. Otherwise an error associating the corresponding label to the errom message <code>&quot;should contain at least one uppercase&quot;</code> would be registered in changeset <code>cset</code>.</p><pre><code>let validate_one_uppercase label cset =
  let message = &quot;should contain at least one uppercase&quot; in
  let aux s =
    if not Base.(String.exists s ~f:Char.is_uppercase)
    then [message]
    else []
  in
  CSet.validate_change label aux cset</code></pre><p>The original <code>validate</code> definition should be extended as follows.</p><pre><code>let validate cset =
  cset
  |&gt; CSet.validate_int Age [`greater_than_or_equal_to 0]
  |&gt; CSet.validate_string_length Password [`min 12]
  |&gt; CSet.validate_format Phone (Str.regexp &quot;^\\+?[1-9][0-9]+$&quot;)
  |&gt; validate_one_uppercase Password</code></pre><h2 id="dynamic"><a href="#dynamic" class="anchor"></a>Dynamic side</h2><p>Information coming from the outside world is not always complete and, as a consequence, we usually have to deal with partial data. Suppose we are implementing a <i>strong password generator</i> API and the only information provided are the phone number and the age. In json format it would be represented as:</p><pre><code>{&quot;age&quot;: 9; &quot;phone&quot;: &quot;+14155552671&quot;}</code></pre><p>The changes in a changeset correspond to an heterogeneous map with bindings for keys of type <code>'a label</code> to values of type <code>'a</code>. This structure allows us to incrementally build the changeset before calling <code>CSet.apply</code>.</p><p>Remember that the job of the API is to generate passwords. As a consequence, when creating a new changeset we also have to generate a value for the password. Our <code>create</code> function is now defined as follows, assuming a function <code>generate_strong_password</code> of type <code>unit -&gt; string</code>.</p><pre><code>let create json =
  let open Yojson.Basic.Util in
  let age = json |&gt; member &quot;age&quot; |&gt; to_int in
  let phone = json |&gt; member &quot;phone&quot; |&gt; to_string in
  CSet.[Age =&gt; age; Phone =&gt; phone]
  |&gt; CSet.put_changes
  |&gt; CSet.put_change Password (generate_strong_password ())
  |&gt; validate
  |&gt; CSet.apply</code></pre><h2 id="limitations"><a href="#limitations" class="anchor"></a>Limitations</h2><p>Parameterized source types are not yet supported.</p></body></html>